# 前言
在过去的工作中，我接触了各种各样的游戏数据配置表格，有的复杂，有的简单，或多或少遇到一些不满意。这里就在简单与复杂中，尝试一个折中方案。用任何语言都可以实现，这里采用python仅仅是为了简单实现原型。

# 配置表格解析与转换
        Excel
        /   \
      Meta  JSON
        |    / \
        |   /   简单文本转换(lua/js...)
    复杂序列化(protobuf/navtive serialization object)

Meta 表格类型描述
- 集合类型
- 字段
- 字段类型

JSON
- 结构简单, 生成容易, 易读写
- 各语言支持良好

作为一个通用的表格解析器，推荐 把Meta 和JSON 作为解析的中间件导出(或者说首要导出)，其他诸如lua/js/protobuf/.... 当作子程序或者其他程序在基于 Meta/JSON 二次导出

因为在不知道具体编程环境，很难导出真正合适的文件。这最后的一步，交给最终编程环境去实现会非常简单且完美契合。



曾经参与的有个项目，客户端u3d中导出c#序列化对象,服务器也要使用配置数据, 于是又写了一份java的数据导出java序列化，后面服务器GM平台又不是用java编写，
于是,为了跨平台，又想换回protobuf. protobuf 解析增删字段，表格定义啊，message 生成，对于需要编译的语言来说，真心有点麻烦(python 这里脚本会比较简单)。。。。总之最后很麻烦

如果一开始，数据导出采用JSON作为中间件，基于JSON良好的支持性，无论二次导出还是直接使用，都是特别简单自由的事情。


# 常用的表格形式
- 列表(dict/list)
- 常数枚举
- 矩阵表格

## 1)列表(list/dict)

| id  | lvl | exp | name   | parse_list | query_one           | query_many            |
| --- | --- | --- | ------ | ---------- | ------------------- | --------------------- |
| int | int | int | string | int[],     | sheet_name|id,name  | sheet_name[]|name,age |
| 1   | 100 | 100 | lucy   | 1,2,3      | 100,aaa             | aaa, 100              |
| 2   | 101 | 200 | mark   | 4,5,6      | 200,bbb             | bbb, 100              |


row0    定义字段

row1    定义类型

row2~n  定义数值

这种类型的配置表格占绝大多数

dict/list 区分仅仅是在存储/访问对象上提供一点点方便，解析定义表格方面二者结构上没有差异


## 2)矩阵表格

| int | b1 | b2 | b3 |
| --- | -- | -- | -- |
| b1  | 0  | 1  | 2  |
| b2  | 1  | 2  | 3  |
| b3  | 1  | 2  | 3  |

矩阵数据类型定义在左上角
```
{
    "head":[b1,b2,b3,b4]
    "array":[ 0,1,2
              1,2,3
              1,2,3
            ]
}
```

这种表格在表示对象关系上是非常重要的。举例子：技能系统中，我们想要描述两个BUFF之间的共存关系，就非常有用


## 3)常量表
| name          | type | value |
| ------------- | ---- | ----- |
| max_acc_level | int  | 10    |
| dungeon_cd    | int  | 1000  |

常量表主要是枚举一些特殊的值，相互可能无关，数量也可能较多，竖向更利于维护



# 4)导出类型
sheet_name
- list
- dict
- object
- table

表格sheet名称就是导出数据类型。默认list

# 5)字段类型定义
基础数据类型
int
float
doubble
bool
string

基础数据列表解析类型
T[]S  (T:基础数据类型,S:分割字符)

查询表达式类型
查询一个 Table|field1,... (Table:数据表格名,filed:字段名)
查询所有 Table[]|field1,...

# 6)excel表格命名连接词
连接词在导出文件时会被忽略
+ 分表连接
User.xls
User+Attr.xls
User+Body.xls
上面三个表最终合并成User一个表格导出。其作用时拆分巨大无比的表格，让编辑维护更简单

- 禁止导出
-UserAni.xls
这样表示这个表格不会被单独导出，但是本身是可以被查询到的

-- 忽略表格
--UserAni.xls
这样表示跳过解析这个表格，当其不存在

# 7)导出格式
json

# 8)字段匹配符
|  id | lvl |
| --- | --- |
| int | int |
|     | *s  |
| 1   | 1   |
| 2   | 1   |

第三行第二列  *s 这是一个匹配符
用于匹配传入的匹配字符，确定是否过滤或者匹配该字段
匹配行是可选的

命令行 --match
--match=+s 空和带s匹配的字段(s可以是任意字符)<br>
--match=-s 不带s匹配的字段(s可以是任意字符)<br>
--match=s  所有s匹配的字段(s可以是任意字符)<br>
--match=-* 所有无匹配的字段<br>
--match=*  所有有匹配的字段<br>

# 9)字段导出前提=>命名合法且有类型标记
非法命名字段忽略导出
没有类型标记的字段忽略导出

字段命名合法字符集 {小写字母, 大小字母, 数字, _}

# 10)数据导出中间件
默认导出为json
但是为支持json到其他数据的转换如protobuf/c#/java 等数据的转换，导出json的同时还会生成一份所有数据表格的类型定义

# 11)排除文件 --excludes
--excludes=UserItem.xls,UserSkill.xls