# 数据导出思路
在过去的工作中，我接触了各种各样的游戏数据配置表格，有的复杂，有的简单，或多或少遇到一些不满意。
这里就在简单与复杂中，尝试一个折中方案。采用python仅仅是为了简单实现原型。
```
本文EXCEL转换思路

        Excel
        /   \
      Meta  JSON
        |    / \
        |   /   简单文本转换(lua/js...)
    复杂序列化(protobuf/navtive serialization object)
```
## Meta
表格类型描述, 可以理解成class定义

## Why JSON?
- 结构简单, 生成容易, 易读写
- 各语言支持良好

作为一个通用的表格解析器，推荐 把Meta 和JSON 作为解析的中间件导出(或者说首要导出)，其他诸如lua/js/protobuf/.... 当作子程序或者其他程序在基于 Meta/JSON 二次导出

因为在不知道具体编程环境，很难导出完美契合项目的代码, 所以这最后的一步，交给最终编程环境去实现会非常简单且完美契合，其实直接使用JSON也可以了。

# EXCEL表格数据集类型定义

| 名称    | 类型         | 说明                    |
| ------ | ------------ | ---------------------- |
| 列表    | list        |                         |
| 字典    | dict        | 第一个字段将会用于构建key  |
| 枚举    | object      |                         |
| 矩阵    | matrix      |                         |
| 稀疏矩阵 | matrix(csr) | CSR存储方式              |

采用**表格名称**定义类型。(表格名称。不是EXCEL文件名)

默认导出类型list.(如果无法识别出sheet_name，则采用默认类型)

## 列表(list/dict)

| ID  | 等级 | 经验 | 名称   | 数组解析式  | 一对一查询            | 一对多查询                |
| --- | --- | --- | ------ | ---------- | ------------------- | ------------------------ |
| id  | lvl | exp | name   | parse_list | query_one           | query_many               |
| int | int | int | string | int[],     | sheet_name\|id,name | sheet_name\[\]\|name,age |
| 1   | 100 | 100 | lucy   | 1,2,3      | 100,aaa             | aaa, 100                 |
| 2   | 101 | 200 | mark   | 4,5,6      | 200,bbb             | bbb, 100                 |

这是使用频率最高的配置表格形式

**定义方式**
- sheet_name = list 或者 dict
- 第一行 注释
- 第二行 字段
- 第三行 类型
- 第四行 字段匹配符号(可选。如果没有查找到匹配符，则认为是数据行)
- 其他行 数值定义

## 矩阵
例:buff之间关系矩阵

|     |     | 注释 | 注释 | 注释 | 注释 |
| --- | --- | --- | ---- | --- | --- |
|     | int | C1  | C2   | C3  | C4  |
| 注释 | R1  | 0   | a12  | a13 | 0   |
| 注释 | R2  | 0   | 0    | 0   | 0   |
| 注释 | R3  | 0   | a32  | 0   | 0   |
| 注释 | R4  | 0   | 0    | 0   | 0   |

矩阵非常有利于描述多个事物之间的关系，必须要提供。

**定义方式**
- sheet_name = matrix 或 matrix(csr)
- 第一行和第一列 为注释行
- (2, 2) 定义数值类型(int/float)
- (2, 3) -- (2, n) 行首值
- (3, 2) -- (n, 2) 列首值
- (3, 3) -- (3, n) 数据区块
<br>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
  (n, 3) -- (n, n)
- 导出数据
```JSON
----------普通导出----------
json string
{
  "type":"int",
  "col_head":[C1, C2, C3, C4],
  "row_head":[R1, C2, R3, R4],
  "matrix":[
    0, a12, a13, 0,
    0, 0,   0,   0,
    0, a32, 0,   0,
    0, 0,   0,   0
  ]
}

----------CSR导出----------
Matrix CSR Storage in JSON
        not empty row count
        |  row index
        |  |     row index
        |  |     |  ___________________
        |  |  ___|_|___                |
        |  | |   | |   |               |
        |  | |   | |  col val col val col val
        |  | |   | |   |  |    |  |    |  |
        |  | |   | |   v  |    |  |    v  |
array   2, 0,5 , 3,9 , 1,a12 , 2,a13 , 1,a32
index   0  1 2   3 4   5 6     7 8     9 10
              
json string
{
  "type":"matrix(csr)",
  "row_head":[C1,C2,C3,C4],
  "col_head":[R1,R2,R3,R4],
  "matrix":[
          2,        //非空行数量
          0,5, 3,9, //非空行号,非空行开始下标
          1,1, 2,2, //行标，值
          1,1       //行标，值
          ]
}

代码实现查找时，可用二分法减少访问行标的时间复杂度
```
## 常量配置表
| comment    | name          | type | value |
| ---------- |-------------- | ---- | ----- |
| 账号最大等级 |max_acc_level  | int  | 10    |
| 地牢冷却时间 |dungeon_cd     | int  | 1000  |
| 体力最大数值 |full_heart_num | int  | 100   |

如上表，在项目中会有很多相互无关，数量可观的配置数据。它们不适合存储成列表形式。如果字段按行展开，阅读编写不便。

**所以常量表如下定义**
- sheet_name = object
- 字段竖向展开
- 行方向依次为:字段注释名，字段，类型，值
- 列方向依次为:列注释名, 数值定义
- 导出结果为一个字典

```JSON
json string
{
  "max_acc_level":10,
  "dungeon_cd":1000,
  "full_heart_num":100
}
```

# 字段类型定义

| 类型                 | 定义符号说明               | 说明                 |
| ------------------- | ------------------------- | ------------------- |
| int                 | 基础类型                   |                     |
| float               | 基础类型                   |                     |
| doubble             | 基础类型                   |                     |
| bool                | 基础类型                   |                     |
| string              | 基础类型                   |                     |
| T[]S                | T:基础类型 S:分隔符         | 解析成数组（不再推荐） |
|                     |                           | 建议使用数组字段合并   |
| Table|field1,...    | Table:查询表 field:查询字段 | 匹配一个             |
| Table[]|field1,...  | Table:查询表 field:查询字段 | 匹配多个,存数组       |
| Table{}|field1,...  | Table:查询表 field:查询字段 | 匹配多个,存字典       |

# 数组字段合并
- 字段以  下划线"_"和数字结尾
- 并且字段值类型一致

| 注释    | 注释  | 注释   | 注释  | 注释   |
| ------ | ----- | ----- | ----- | ----- |
| name   | ids_0 | ids_1 | ids_2 | ids_3 |
| string | int   | int   | int   | int   |
| abc    | 0     | 1     | 2     | 3     |

```JSON
json string
{
    "name":"abc",
    "ids":[0,1,2,3]
}
```

# 字段匹配符”*“
| 注释 | 注释 |
| --- | --- |
|  id | lvl |
| int | int |
|     | *s  |
| 1   | 1   |
| 2   | 1   |

第三行第二列  *s 这是一个匹配符
用于匹配传入的匹配字符，确定是否过滤或者匹配该字段
匹配行是可选的

命令行 --match
--match=+s 空和带s匹配的字段(s可以是任意字符)<br>
--match=-s 不带s匹配的字段(s可以是任意字符)<br>
--match=s  所有s匹配的字段(s可以是任意字符)<br>
--match=-* 所有无匹配的字段<br>
--match=*  所有有匹配的字段<br>

# 表格文件 命名连接词
连接词在导出文件时会被忽略

## 分表连接符号”+“
User.xls
User+Attr.xls
User+Body.xls
上面三个表最终合并成User一个表格导出。其作用时拆分巨大无比的表格，让编辑维护更简单

## 禁止导出连接符号"-"
-UserAni.xls
这样表示这个表格不会被单独导出，但是本身是可以被查询到的

## 忽略表格”--“
--UserAni.xls
这样表示跳过解析这个表格，当其不存在

# 注意事项(杂项)

- 字段导出前提=>命名合法且有类型标记
- 非法命名字段忽略导出
- 没有类型标记的字段忽略导出
- 字段命名合法字符集 {小写字母, 大小字母, 数字, _}

# 特殊参数说明
## --excludes 排除文件
--excludes=UserItem.xls,UserSkill.xls

## --start 表格解析起始偏移量
默认值为1，即0索引留给注释。如果设置0，表示所有表格都不写开始注释行/列。不建议修改此参数
